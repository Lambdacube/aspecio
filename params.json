{
  "name": "Aspecio",
  "tagline": "A Java/OSGi R6 'micro-framework' that brings a mix of component-oriented and aspect-oriented programming to your application.",
  "body": "# Aspecio\r\n\r\nAspecio is a Java/OSGi R6 'micro-framework' that brings a mix of component-oriented and aspect-oriented programming to your application. Aspecio lets you define _Aspects_ that you can later pick to add behavior to your components and avoid duplicating boilerplate dealing with cross-cutting concerns.\r\n\r\n\r\n**Disclaimer**\r\n\r\nThis documentation is a work-in-progress. Aspecio is ready for a first release, but do not hesitate to contact me for questions. I will update the documentation accordingly.\r\n\r\n\r\n\r\n## Overview\r\n\r\n\r\n### Why Aspects?\r\n\r\nIn general, aspects allow you to intercept code and alter its execution. There are a number of downsides of using aspects:\r\n* Scattering behavior across the code base ;\r\n* Making the execution model opaque by having aspects intercept any random piece of code, including internal code that might have implicit invariants that aspects break ;\r\n* Not knowing **which** aspects are being _woven_ on a piece of code at a given time ;\r\n* Having some aspect framework implementations _weave_ aspects into one big bytecode muddy-ball, making debugging difficult when line numbers are desynchronized, adding synthetic methods in the bytecode.\r\n* Sometimes aspects are implemented using JDK Proxies, which can break consuming code, for example code relying on reflection such as annotation-driven frameworks.\r\n\r\nHowever there are _cross-cutting concerns_ for which aspects can be very useful, for example:\r\n* Security: ensuring some conditions are met before being allowed into a function ; \r\n* Metrics: having live metrics on key components (e.g using Coda Hale's Metrics library) ;\r\n* Ensuring a piece of code takes place in a transaction ;\r\n* And more :-)\r\n\r\nAspecio aims to make aspects predictable and bridges them with the OSGi service model.\r\n\r\n\r\n### Aspecio and OSGi\r\n\r\nWhile Aspecio's internal weaving code could be interesting to plug to other Dependency Injection frameworks, it currently supports exclusively OSGi R6 out of the box.\r\n\r\nAs it is, Aspecio works with OSGi Services and can weave almost any _willing_ OSGi service (only OSGi services registered as a class and not an interface, which a bad practice, cannot be woven using Aspecio). \r\n\r\nAspecio works with any service scope, `singleton`, `bundle` and `prototype` and will only create as many instances as expected. In case of service frameworks using the `bundle` scope to make service creation lazy (such as Declarative Services), but still having effectively `singleton` services, Aspecio will make sure each service instance has exactly one proxy instance.\r\n\r\nThanks to relying on OSGi's low-level service primitives, Aspecio can work with any OSGi service component framework, including any compliant implementation of Declarative Services, Blueprint, Guice + Peaberry, Apache Felix iPojo or Apache Felix DependencyManager.\r\n\r\nAspecio has been tested on Felix 5.4.0 but should work with any framework compliant with OSGi R6.\r\n\r\nIn the following examples, Declarative Services will be used.\r\n\r\n\r\n### Aspecio's weaving\r\n\r\nAspecio picks service objects that ask for certain aspects in their service properties, hiding (by default) the original service from all bundles except the system bundle and Aspecio itself.\r\n\r\nAspecio dynamically generates a proxy implementing all the interfaces and public methods of the same service using the ASM bytecode generation library, that have extra logic for call interception, and naturally delegates to the original service object.\r\n\r\nThe Aspecio proxy is designed to expose most of the woven service object's metadata: \r\n* Same method parameter names (will work with Java 8's `-parameters` compile switch) ;\r\n* Same runtime annotations on the types, methods and method parameters ;\r\n* Same generic method signatures on types and methods.\r\n\r\nThis way, any piece of code consuming a service proxied by Aspecio rather than the original instance should be clueless about it and work exactly the same, including reflection code.\r\n\r\nFinally, Aspecio proxies are meant to be as efficient as can be:\r\n* No primitive boxing whatsoever ;\r\n* Lazy weaving of Aspects when a class is loaded (for instance, to obtain an instance of the arguments of a specific method call) ;\r\n* Interception has different levels of detail, which are all \"opt-in\", so no one pays for what they don't use.\r\n\r\n\r\n### Aspecio's dependencies\r\n\r\nAspecio only depends on Java 8 and OSGi R6. It has an optional dependency on SLF4J so that it will be used if it is `RESOLVED` before Aspecio is (or you can issue a `refresh` to rewire it). Aspecio will use JUL loggers if SLF4J is not found.\r\n\r\n\r\n### Installing Aspecio in an OSGi Framework\r\n\r\nIt is better to install Aspecio early, before bundles making use of it are installed, because OSGi's R6 service hook do not allow \"breaking\" existing service bindings. \r\n\r\n\r\n## Defining an Aspect with Aspecio\r\n\r\nIn Aspecio, we use Java to declare an Aspect.\r\n\r\nHere is a simple Aspect counting how many times a method has been called. Depending on its configuration, it may count only successful calls (e.g, methods that did not throw an exception) or all methods indiscriminately. \r\n\r\n```java\r\n@Component\r\n@Aspect(provides = CountingAspect.class)\r\npublic final class CountingAspectImpl implements Interceptor {\r\n\r\n    private final Map<Method, Integer> methodCallCount = Maps.newConcurrentMap();\r\n    \r\n    // This could be dynamically configured using Declarative Service + ConfigAdmin\r\n    private volatile boolean countOnlySuccessful = false;\r\n\r\n    @Override\r\n    public Advice onCall(CallContext callContext) {\r\n        if (countOnlySuccessful) {\r\n            return new AdviceAdapter() {\r\n                @Override\r\n                public int afterPhases() {\r\n                    return CallReturn.PHASE;\r\n                }\r\n\r\n                @Override\r\n                public void onSuccessfulReturn() {\r\n                    methodCallCount.compute(callContext.method, (k, v) -> v == null ? 1 : (v += 1));\r\n                }\r\n            };\r\n        } else {\r\n            methodCallCount.compute(callContext.method, (k, v) -> v == null ? 1 : (v += 1));\r\n            return Advice.DEFAULT;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\nAspecio finds Aspects by:\r\n* Looking for OSGi Services ; in the example above, provided using the `@Component` Declarative Service annotation)\r\n* That provide the OSGi service String property `AspecioConstants.SERVICE_ASPECT` (`\"service.aspect\"`) ; in the example above, declared using the `@Aspect` annotation using the [BND Declarative Services Annotation Property Plugin](https://github.com/lambdacube/bnd-dsap-plugin).\r\n* That implement the interface `io.lambdacube.aspecio.aspect.interceptor.Interceptor` (it need not be provided as the service's `\"objectClass\"`).\r\n* If several services provide an aspect, Aspecio will pick the one with the highest-service ranking ; in case of equal service rankings, Aspecio will pick the one with the lowest service id. Aspecio supports OSGi's service dynamics and will happily replace or update Aspects live. Aspecio is always 'greedy': if a \"better\" interceptor is registered for a given aspect, all the services using it will have it updated immediately. \r\n\r\nIn the example above, our component `CountingAspectImpl` provides the aspect named `\"io.lambdacube.aspecio.examples.aspect.counting.CountingAspect\"` (a Java String). You can name your aspects with any String, but it is practical to use Java classes to piggyback on the namespaces. \r\n\r\nInterceptors define the method `Advice onCall(CallContext callContext)` that will be called anytime a method from a woven service is called. \r\n\r\n\r\n### Advanced interception: Advices in Aspecio\r\n\r\nTODO advice automata\r\n\r\nJavadoc is more or less complete on Advices.\r\n\r\n### Composing Aspects\r\n\r\nTODO write this :)\r\n\r\n\r\n## Aspect Weaving with Aspecio\r\n\r\nIn Aspecio, we can only weave OSGi services that opt-in to one or several aspects. This is because services have a well-defined contract and make it the perfect entry point for aspects.\r\n\r\nServices must declare the OSGi service `String` or `String[]` property `\"service.aspect.weave\"` (for required aspects) or `\"service.aspect.weave.optional\"` (for optional aspects), with the aspect names as value, to be candidate for weaving.\r\n\r\n### A simple example\r\n\r\nHere is a Declarative Services component that will be woven by Aspecio using our `CountingAspect` declared earlier. Again, you can see that we use a custom service property annotation, `@Weave`, that is picked-up by the [BND Declarative Services Annotation Property Plugin](https://github.com/lambdacube/bnd-dsap-plugin).\r\n\r\n\r\n```java\r\n@Component\r\n@Weave(required = CountingAspect.class, optional = AnotherOptionalAspect.class)\r\npublic final class HelloGoodbyeImpl implements Hello, Goodbye {\r\n\r\n    @Override\r\n    public String hello() {\r\n        return \"hello\";\r\n    }\r\n\r\n    @Override\r\n    public String goodbye() {\r\n        return \"goodbye\";\r\n    }\r\n\r\n}\r\n```\r\n\r\nThat's all! Now any aspect woven will be notified with the calls of methods `hello()` or `goodbye()` and may interact by returning other values, throwing exceptions, catching exceptions, accessing the arguments of each call (or just some) or even update the arguments before the call takes place.\r\n\r\nAlso, because `\"i.l.a.e.a.c.CountingAspect.class\"` is `required` by `HelloGoodbyeImpl`, the service will **not** be visible until a service providing Aspect `\"i.l.a.e.a.c.CountingAspect.class\"` is available. All the kinds of OSGi dynamism can happen here: the aspect can be registered after a service requiring it or later. \r\n\r\nHaving `\"i.l.a.e.a.a.AnotherOptionalAspect.class\"` as an optional aspect will not prevent Aspecio's proxy of `HelloGoodbyeImpl` of being registered even in case `\"i.l.a.e.a.a.AnotherOptionalAspect.class\"` is missing ; however if it becomes available during `HelloGoodbyImpl`'s lifetime, it will start intercepting its methods as well.\r\n\r\n\r\n\r\n## Aspect patterns\r\n\r\n### Annotation-based interception\r\n\r\n* When you want to intercept only certain annotated methods, and you can use the annotation to pass configuration to the interceptor ;\r\n* When you annotate certain method parameters to guide your aspect.\r\n\r\n```java\r\n@Component\r\n@Aspect(provides = MyAnnotationDrivenAspect.class)\r\npublic final class MyAnnotationDrivenAspectImpl implements AnnotationInterceptor<MyAnnotation> {\r\n\r\n    @Override\r\n    public Advice onCall(MyAnnotation myAnn, CallContext callContext) {\r\n         // myAnn may contain previous info on how to use the aspect.\r\n         ...\r\n    }\r\n    \r\n    @Override\r\n    public Class<MyAnnotation> intercept() {\r\n        return MyAnnotation.class;\r\n    }\r\n}\r\n```\r\n\r\n\r\nSee `AnnotationInterceptor`.\r\n\r\n\r\n### Aspects that bridge services\r\n\r\nBecause we rarely want the actual cross-cutting behavior to reside in our interceptor, it is a better approach to use your favorite component framework to make your aspects merely bring a functionality provided elsewhere:\r\n\r\n\r\n```java\r\n@Component\r\n@Aspect(provides = MyFeatureAspect.class)\r\npublic final class MyFeatureAspectImpl implements Interceptor {\r\n\r\n    @Reference\r\n    private MyFeature; // logic is in another service\r\n\r\n    @Override\r\n    public Advice onCall(CallContext callContext) {\r\n         // notify MyFeature appropriately  \r\n         ...\r\n    }\r\n}\r\n\r\n```\r\n\r\n### Interceptors that register extra service properties\r\n\r\n\r\n```java\r\n@Component\r\n@Aspect(provides = MySecurityAspect.class, extraProperties = \"secured\")\r\npublic final class MySecurityAspectImpl implements Interceptor {\r\n\r\n    @Override\r\n    public Advice onCall(CallContext callContext) {\r\n         ...\r\n    }\r\n}\r\n\r\n```\r\n\r\nThe proxy service object registered by Aspecio will have the OSGi service Boolean property `\"secured\"` set to `Boolean.TRUE`. Now consuming code can check for that property to know if a service is secure, on only select secured services using a target filter. The consuming code doesn't need to know whether a service was secured manually or using an aspect, and this enables just that.\r\n\r\n\r\n\r\n## Maven coordinates\r\n\r\nSoon on Maven Central :-)\r\n\r\n\r\n## Credits / Contact\r\n\r\nAuthor: Simon Chemouil. \r\n\r\n(c) Simon Chemouil & Lambdacube\r\n\r\nAsk questions directly on Twitter `@simach`\r\n\r\nOpen bugs on Github issues.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}